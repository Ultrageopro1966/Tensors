   

# Создание тензора

Так как класс поддерживает только трехмерные тензоры, то задать из кода его можно так:
```cpp
Tensor t({{{0, 0}, {0, 0}}, {{0, 0}, {0, 0}}}); \\ создание тензора t
```

Класс поддерживает трехмерные тензоры произвольных размеров.
## Атрибуты класса Tensor
### Методы доступа к атрибутам
1. `.getSize()` возвращает размеры тензора в формате `vector<int>`
2. `.getTensor()` возвращает тензор в формате `vector<vector<vector<double>>>`
### Методы изменения атрибутов
1. `.setTensor(vector<vector<vector<double>>> new_tensor)` задает текущему тензору значение нового тензора и, соответственно, новые размеры.
2. `.setTensorValue(int z, int y, int x, double value)` задает значению тензора по индексу $T_{zyx}$ новое значение `value`
## Ввод и вывод тензора из файла/консоли

### Вывод/запись тензора в файл/консоль

Перегруженный оператор `<<` выводит заданный тензор в читаемом формате в консоль/текстовый файл. Пример использования:

```cpp
int main(){
    Tensor t({{{1, 2, 3}, {1, 2, 30}, {1, 2, -30}}, {{1, 2, 3}, {1, 2, 30}, {1, 2, -30}}, {{1, 2, 3}, {1, 2, 30}, {1, 2, -30}}});
    cout << t;
    return 0;
}

```
Вывод программы:

```
{
 {
  { 1 2 3 }
  { 1 2 30 }
  { 1 2 -30 }
 }
 {
  { 1 2 3 }
  { 1 2 30 }
  { 1 2 -30 }
 }
 {
  { 1 2 3 }
  { 1 2 30 }
  { 1 2 -30 }
 }
}

```

Запись в текстовый файл происходит точно так же.

### Чтение тензора из файла/консоли.
Для чтения тензора из файла/консоли необходимо создать новый тензор:
```cpp
Tensor t({{{0}}});
```

И записать в него новый тензор:

```cpp
int main(){
    Tensor t({{{0}}});
    cin >> t;
    return 0;
}

```

Например, при вводе пользователем строки `{{{0, 1}, {0, 1}}, {{0, 1}, {0, 1}}}` в тензор запишется введенное значение. Вывод такого тензора будет:

```
{
 {
  { 0 1 }
  { 0 1 }
 }
 {
  { 0 1 }
  { 0 1 }
 }
}

```

# Операции с тензорами


## Преобразование тензора
### Транспонирование

По правилу транспонирования трехмерных тензоров местами меняются крайние индексы. Метод `.transpose()` возвращает транспонированный тензор.

Пример транспонирования тензора:
```cpp
int main(){
    Tensor t1({{{0, 1}, {0, 1}}, {{0, 1}, {0, 1}}});
    t1 = t1.transpose();
    cout << t1;
    return 0;
}

```

Вывод будет таким:

```
{
 {
  { 0 0 }
  { 0 0 }
 }
 {
  { 1 1 }
  { 1 1 }
 }
}

```

### Симметризация/антисимметризация тензора

Доступны методы симметризации по двум и трем индексам и антисимметризации по трем индексам:

1. `.symmetrize_3()` - симметризация по всем трем осям
2. `.symmetrize_2(int dim1, int dim2)` - симметризация по двум выбранным осям
3. `.anty_symmetrize_3()` - антисимметризация по всем трем осям.

Пример использования симметризации по трем осям:

```cpp

int main(){
    Tensor t1({{{5, 1, 1}, {-4, 1, 1}, {2, 1, 1}}, {{2, 1, 1}, {8, 1, 1}, {2, 1, 1}}, {{2, 1, 1}, {8, 1, 1}, {2, 1, 1}}});
    t1 = t1.symmetrize_3();
    cout << t1;
    return 0;
}

```

Вывод будет таким:

```

{
 {
  { 5 -0.333333 1.66667 }
  { -0.333333 3.33333 2.33333 }
  { 1.66667 2.33333 1.33333 }
 }
 {
  { -0.333333 3.33333 2.33333 }
  { 3.33333 1 1 }
  { 2.33333 1 1 }
 }
 {
  { 1.66667 2.33333 1.33333 }
  { 2.33333 1 1 }
  { 1.33333 1 1 }
 }
}

```

### Свертка тензора
Свертка тензора проводится по правилу суммирования элементов. Результатом получится тензор, размерность которого будет меньше на 2. Для свертки тензора используется метод `.convolution()`

Пример использования:

```cpp
int main(){
    Tensor t1({{{5, 1}, {-4, 1}, {2, 1}}, {{2, 1}, {8, 1}, {2, 1}}, {{2, 1}, {8, 1}, {2, 1}}});
    t1 = t1.convolution();
    cout << t1;
    return 0;
}
```

Программа выведет
```
{
 {
  { 12 15 9 }
 }
}
```

  

## Операции с двумя тензорами
### Операторы `*` и `+` для двух тензоров
Данные операторы производят поэлементное сложение/умножение двух тензоров

### Операторы `*` и `+` для тензора и скаляра
Данные операторы производят умножение/сложение скаляра с каждым элементом тензора

### Метод умножения двух тензоров
Метод `.multiply(const Tensor& ten2)` позволяет перемножить два тензора непоэлементно. Аналогом является функция в Python `numpy.matmul(tensor1, tensor2)`

Пример использования:
```cpp

int main() {
    Tensor t1({ {{2, 1}, {4, 1}}, {{1, 1}, {10, 1}} });
    Tensor t2({ {{2, 1}, {4, 1}}, {{1, 1}, {10, 1}} });
    cout << t1.multiply(t2);
    return 0;
}
```

Вывод программы:

```
{
 {
  { 8 3 }
  { 12 5 }
 }
 {
  { 11 2 }
  { 20 11 }
 }
}

```
### Расширяющее произведение
Метод `.multiply6()` позволяет перемножить 2 трехмерного тензора. Метод возвращает 6-мерный вектор, который можно вывести с помощью перегруженного оператора `<<`
Пример использования:
```cpp
int main() {
    Tensor t1({ {{2, 1}, {4, 1}}, {{1, 1}, {10, 1}} });
    cout << t1.multiply_6(t1);
    return 0;
}
```

Вывод программы:
```
{
  {
    {
      {
        {
          { 4 2 },
          { 8 2 },
        },
        {
          { 2 2 },
          { 20 2 },
        },
      },
      {
        {
          { 2 1 },
          { 4 1 },
        },
        {
          { 1 1 },
          { 10 1 },
        },
      },
    },
    {
      {
        {
          { 8 4 },
          { 16 4 },
        },
        {
          { 4 4 },
          { 40 4 },
        },
      },
      {
        {
          { 2 1 },
          { 4 1 },
        },
        {
          { 1 1 },
          { 10 1 },
        },
      },
    },
  },
  {
    {
      {
        {
          { 2 1 },
          { 4 1 },
        },
        {
          { 1 1 },
          { 10 1 },
        },
      },
      {
        {
          { 2 1 },
          { 4 1 },
        },
        {
          { 1 1 },
          { 10 1 },
        },
      },
    },
    {
      {
        {
          { 20 10 },
          { 40 10 },
        },
        {
          { 10 10 },
          { 100 10 },
        },
      },
      {
        {
          { 2 1 },
          { 4 1 },
        },
        {
          { 1 1 },
          { 10 1 },
        },
      },
    },
  },
}
```
Получается 6-мерный вектор с 64 элементами.

****
